 ## 5장. **시스템 정보**

  * [5-1 시스템 정보 검색](#5-1-시스템-정보-검색)

### 5-1 시스템 정보 검색
1. 운영체제 기본 정보 검색  
현재 시스템에 설치되어 있는 운영체제의 정보를 호출하기 위해서는 **uname -a** 라는 명령어를 사용한다.  
커널명, 호스트명, 커널 릴리즈, 커널 버전, 하드웨어명, 프로세서명, 플랫폼명, 운영체제명 순으로 출력한다.  

``` 
$ uname -a
Linux ubuntu 5.13.0-41-generic #46~20.04.1-Ubuntu SMP Wed Apr 20 13:16:21 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
```
2. 운영체제 정보 검색  
int uname(struct utsname *buf)  
buf : utsname 구조체 주소  
return value : 성공하면 0, 실패하면 -1
    * [uname 구조체](#참고-uname-구조체)

3. 시스템 자원 정보 검색  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|long sysconf(int name)|시스템 자원 정보 검색|name: 검색할 정보를 나타내는 상수|시스템 자원값 or 옵션값, 오류가 발생하면 -1|
|long fpathconf(int fd, int name)|파일과 디렉터리 자원 검색|fd : 파일 기술자</br>name : 검색할 정보를 지정하는 상수|성공하면 정수, 실패하면 -1|
|long pathconf(const char *path, int name)|파일과 디렉터리 자원 검색|path : 파일이나 디렉터리  경로</br>name : 검색할 정보를 지정하는 상수)|성공하면 정수, 실패하면 -1|
 * [sysconf에 사용되는 상수](#참고-sysconf에-사용되는-상수)  
 * [fpathconf/pathconf에 사용되는 상수](#참고-fpathconfpathconf에-사용되는-상수)

### 5-2 사용자 정보 검색

리눅스 시스템에서 알 수 있는 사용자 정보는 각 사용자에 대한 정보, 그룹에 대한 정보, 로그인 기록 정보가 있다.  
이 정보들과 직접적으로 관련이 있는 파일은 패스워드 파일(/etc/passwd), 섀도우 파일(/etc/shadow), 그룹 파일(/etc/group), 로그인 기록 파일(/var/run/utmp)이 있다.

1. 로그인명과 UID 검색  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|char *getlogin(void)|로그인명 검색||현재 프로세스를 실행한 사용자의 로그인명, 로그아웃을 했거나 원격에서 프로세스를 실행하 경우 NULL|
|uid_t getuid(void)|UID 검색||실제 사용자 ID|
|uid_t geteuid(void)|UID 검색||유효 사용자 ID|  

**실제 사용자 ID(RUID)** : 로그인시 사용한 로그인 명에 대응하는 UID로, 프로그램을 실행하는 사용자  
**유효 사용자 ID(EUID)** : 프로세스에 대한 접근 권한을 부여할때 사용됨. 처음 로그인할떄 실제 사용자 ID와 유효자용자 ID는 같지만, setuid가 설정된 프로그램을 실행하거나 다른 사용자 ID로 변경할 경우 유효 사용자 ID는 달라짐

2. 패스워드 파일 검색  
패스워드 파일(/etc/passwd)에는 로그인명, UID, GID, 사용자의 홈 디렉터리, 로그인 셸등 사용자의 기본 정보에 대한 내용이 들어있다.  

* /etc/passwd 파일의 구조  

```
$ cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
user1:x:1000:1000:sample user:/home/user1:/bin/bash
로그인ID:패스워드:UID:GID:계정 설명:홈 디렉터리:로그인 셸
```
* passwd 구조체  
/etc/passwd 파일의 정보를 읽어오려면 passwd구조체를 사용해야함.  
``` c
struct passwd{
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gceos;
    char *pw_dir;
    char *pw_shell;
}​;
```
pw_name : 로그인명  
pw_passwd : 암호(요즘은 거의 대부분 리눅스 시스템이 암호를 별도의 파일(/etc/shadow)에 저장하므로 의미없는 항목임)  
pw_uid : UID  
pw_gid : 기본 그룹 IU  
pw_gceos : 사용자 실명이나 기타 정보를 저장  
pw_dir : 홈 디렉터리  
pw_shell : 로그인 셸  

* UID로 /etc/passwd 파일 읽기  
struct passwd *getpwuid(uid_t uid)  
uid : 검색할 uid  
return value : passwd 구조체의 주소, 실패하면 NULL  

* 이름으로 /etc/passwd 파일 읽기  
struct passwd *getpwnam(const char *name)  
name : 로그인 명  
return value : passwd 구조체의 주소, 실패하면 NULL  

* /etc/passwd 를 순차적으로 읽기  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|struct passwd *getpwent(void)|사용자의 정보를 순차적으로 읽어옴||파일의 끝을 만나면 NULL|
|void setpwent(void)|/etc/passwd 파일의 오프셋을 파일의 처음에 놓음|||
|void endpwent(void)|/etc/passwd 파일을 닫음|||
|struct passwd *fgetpwent(FILE *stream)|/etc/passwd 파일이 아닌 파일 포인터가 가르키는 파일에서 사용자 정보를 얻음</br>(파일의 내부 구조가 /etc/passwd 와 같아야 함)|stream : 파일 포인터|passwd 구조체의 주소, 실패하면 NULL|

3. 셰도우 파일 검색
  
초기 유닉스 시스템은 사용자 계정의 패스워드 정보를 패스워드 파일에 저장했다.  
하지만 패스워드 파일은 누구나 읽을 수 있기 때문에 보안 문제가 발생할수 있다.  
그래서 현재 대부분의 리눅스와 유닉스 시스템은 사용자 패스워드를 섀도우 파일(/etc/shadow)에 별도 저장하고 있다.

* /etc/shadow 파일의 구조  

```
~$ sudo cat /etc/shadow
[sudo] password for dylee: 
root:!:19120:0:99999:7:::
daemon:*:19046:0:99999:7:::
bin:*:19046:0:99999:7:::
...
user1:$1$B/viKw8d$KMPe1tfvmdzEVIPcdKpqb0:19120:0:99999:7:::
로그인ID:패스워드:최종 변경일:min:max:warn:inactive:expire:flag
```

* /etc/shadow 파일 검색  
struct spwd *getspnam(const char *name)  
name : 검색할 사용자명  
return value : passwd 구조체의 주소, 실패하면 NULL  

* /etc/shadow 를 순차적으로 읽기  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|struct spwd *getspent(void)|패스워드 정보를 순차적으로 읽어옴||파일의 끝을 만나면 NULL|
|void setspent(void)|/etc/shadow 파일의 오프셋을 파일의 처음에 놓음|||
|void endspent(void)|/etc/shadow 파일을 닫음|||
|struct spwd *fgetspent(FILE *stream)|/etc/shadow 파일이 아닌 파일 포인터가 가르키는 파일에서 페스워즈 정보를 얻음</br>(파일의 내부 구조가 /etc/shadow 와 같아야 함)|stream : 파일 포인터|pswd 구조체의 주소, 실패하면 NULL|

4. 그룹 정보 검색
리눅스 시스템에서 사용자는 하나이상의 그룹에 속한다.  

* 그룹 ID 검색  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|gid_t getgid(void)|실제 그룹 ID(로그인시 사용한 사용자의 기본 그룹)를 받아옴||실제 그룹 ID|
|gid_t getegid(void)|유효 그룹 ID(프로세스 접근 권한을 부여할때 사용)를 받아옴||유효 그룹 ID|

5. 그룹 정보 파일 검색  
리눅스에서는 그룹 절보를 /etc/group 파일에 별도로 저장한다.  

* /etc/group 파일의 구조  

```
~$ cat /etc/group
root:x:0:
daemon:x:1:
bin:x:2:
sys:x:3:
adm:x:4:syslog,dylee
tty:x:5:syslog
...
```

* group 구조체  
/etc/group 파일의 정보를 읽어오려면 group 사용해야함.  
``` c
struct group {
    char    *gr_name;
    char    *gr_passwd;
    gid_t   gr_gid;
    char    **gr_mem;
};
```
gr_name : 그룹명  
gr_passwd : 그룹 패스워드(보통은 공백, 그룹 패스워드를 사용하면 암호화된 문자가 저장됨)  
gr_gid : 그룹 ID  
gr_mem : 그룹 멤버인 로그인명을 저장, 문자열을 가리키는 포인터임  


* /etc/group 파일 검색  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|struct group *getgrnam(const char *name)|그룹명으로 그룹 정보를 읽어옴|name : 검색하려는 그룹명|group 구조체의 주소|
|struct group *getgrid(gid_t gid)|그룹ID로 그룹 정보를 읽어옴|gid : 검색하려는 그룹의 ID|group 구조체의 주소|

* /etc/group 를 순차적으로 읽기  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|struct group *getgrent(void)|그룹 정보를 순차적으로 읽어옴||파일의 끝을 만나면 NULL|
|void setgrent(void)|/etc/group 파일의 오프셋을 파일의 처음에 놓음|||
|void endgrent(void)|/etc/group 파일을 닫음|||
|struct group *fgetgrent(FILE *stream)|/etc/group 파일이 아닌 파일 포인터가 가르키는 파일에서 그룹 정보를 얻음</br>(파일의 내부 구조가 /etc/group 과 같아야 함)|stream : 파일 포인터|pswd 구조체의 주소, 실패하면 NULL|

6. 로그인 기록 검색  
who 명령으로 현재 시스템에 로그인한 자용자의 정보를 검색할 수 있다.  
last 명령으로는 시스템의 부팅 시간 정보나 사용자의 로그인 기록들을 검색할 수 있다.  
*우분투 리눅스* 에서는 이러한 정보를 **/var/run/utmp 와 /var/log/wtmp** 파일에 저장한다.  
이 두 파일은 바이너리 형태로 저장되기 때문에 파일의 구조와 관련된 구조체와 함수가 필요하다.  

* utmp 구조체
utmp 파일과 wtmp 파일은 구조가 같다.  
이 두 파일을 읽기 위해서는 utmp 구조체가 필요하다.
``` c
struct utmp                                                       
{
    short                   ut_type;
    pid_t                   ut_pid;
    char                    ut_line[UT_LINESIZE];
    char                    ut_id[4];
    char                    ut_user[UT_NAMESIZE];
    char                    ut_host[UT_HOSTSIZE];
    struct exit_status      ut_exit;
    long                    ut_session;
    struct timeval          ut_tv;
    int32_t                 ut_addr_v6[4];
    char                    __unused[20];
};
```

ut_type : 현재 읽어온 항목에 저장된 데이터 형식 [ut_type에 사용할 수 있는 상수](#참고-uttype에-사용할-수-있는-상수)  
ut_pid : 로그인 프로세스의 pid  
ut_line : 사용자가 로그인한 장치명  
ut_id : 터미널 이름이거나 /etc/inittab 파일에서 읽어온 ID  
ut_user : 사용자명  
ut_host : 원격 로그인을위한 호스트 이름  
ut_exit : 프로세스가 DEAD_PROCESS인 경우 프로세스의 종료 상태를 저장 [exit_status 구조체](#참고-exitstatus-구조체)  
ut_session : 해당 정보의 세션 번호  
ut_tv : 해당 정보를 마지막으로 변경한 시각  
ut_addr_v6 : 원격 접속한 경우 원격 호스트의 인터넷 주소를 저장  
__unused : 추후 사용을 위해 예약된 부분


* /var/log/utmp 파일 순차적으로 읽기  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|struct utmp *getutent(void)|로그인 정보를 순차적으로 읽어옴||파일의 끝을 만나면 NULL|
|void setutent(void)|/var/log/utmp 파일의 오프셋을 파일의 처음에 놓음|||
|void endutent(void)|/var/log/utmp 파일을 닫음|||
|int utmpname(const char *file)|로그인 정보 파일을 파일로 지정한 다른 파일로 변경|file : 지정한 파일명||

### 5-3 시간 관리 함수  
리눅스 시스템은 1970년 1월 1일 0시 0분 0초부터 현재까지 경과한 시간을 초단위로 저장하고 이를 기준으로 시간 정보를 관리한다. 초단위로 저장된 시간을 그대로 활용하기도 하지만 사람이 보기 편한 병태로 바꿔야할때도 있다.  

1. 기본 시간 정보 확인  
이눅스에서 현재 시간 정보를 구하는 기본 함수는 time()이다.  
BSD에서 도입한 gettimeofday() 함수도 시간을 초단위로 알려준다.  

* 초 단위로 현재 시간 정보 얻기  
time_t time(time_t *tloc)  
tloc : 검색한 시간 정보를 저장할 주소  
return value : 성공하면 시간 정보, 실패하면 -1

* 마이크로초 단위로 시간 정보 얻기  

|함수|설명|인자 설명|return value|
|:--:|--|--|--|
|int gettimeofday(struct timeval *tv, struct timezone *tz)|시간 정보를 timeval 구조체에 저장해 리턴 하는 함수|tv : 시간 정보 구조체 주소</br>tz : 시간대 정보 구조체 주소|성공하면 0, 실패하면 -1|
|int settimeofday(const struct timeval *tv, const struct timezone *tz)|시간을 설정하는 함수|tv : 시간 정보 구조체 주소</br>tz : 시간대 정보 구조체 주소|성공하면 0, 실패하면 -1|  
* [timeval 구조체](#참고-timeval-구조체)

2. 시간대 정보  
* 시간대 설정  
void tzset(void)  
tzset() 함수는 현재 지역의 시간대로 설정한다. 이 함수를 호출하면 아래 전역 변수에 정보가 설정된다.
``` c
extern char *tzname[2];
extern long timezone;
extern int daylight;
```
tzname : 지역 시간대와 보정된 시간대명을 약어로 저장  
timezone : UTC와 지역 시간대와 시차응 초 단위로 저장  
daylight : 서머타임제를 시행하면 0이 아니고, 서머타임제를 시행하지않으면 0임  

##### (참고) uname 구조체  
``` c
struct uname{
    char sysname[];
    char nodename[];
    char release[];
    char version[];
    char machine[];
};
```
sysname : 현재 운영체제의 이름  
nodename : 네트워크 통신시 사용하는 시스템 이름  
release : 운영체제 릴리즈 번호  
version : 운영체제 버전 번호  
machine : 하드웨어 표운 이를(아키텍쳐)  

##### (참고) sysconf에 사용되는 상수
|상수명|기능|
|:--:|--|
|_SC_ARG_MAX|exec() 계열 함수에 사용하는 인자의 최대크기|
|_SC_CHILD_MAX|한 UID에 허용되는 최대 프로세스 개수|
|_SC_HOST_NAME_MAX|포스트명의 최대 길이|
|_SC_LOGIN_NAME_MAX|로드인명의 최대 길이|
|_SC_CLK_TCK|초당 클록 틱 수|
|_SC_OPEN_MAX|츠로세스당 열수있는 최대 파일 수|
|_SC_PAGESIZE|시스템 메모리 체이지 크기|
|_SC_VERSION|시스템이 지원하는 POSIX.1의 버전|

##### (참고) fpathconf/pathconf에 사용되는 상수
|상수명|기능|
|:--:|--|
|_PC_LINK_MAX|파일에 가능한 최대 링크 수|
|_PC_NAME_MAX|파일명의 최대 길이를 바이트 크기로 표시|
|_PC_PATH_MAX|상대 경로명의 최대 길이를 바이트 크기로 표시|

##### (참고) ut_type에 사용할 수 있는 상수
|이름|상수|의미|
|:--:|:--:|--|
|EMPTY|0|빈 항목|
|RUN_LVL|1|시스템의 런레벨이 변경 되었음을 나타냄|
|BOOT_TIME|2|시스템 부팅 시각|
|NEW_TIME|3|시스템 클럭이 변경된 다음의 시간 정보|
|OLD_TIME|4|시스템 클럭이 변경되기 전의 시간 정보|
|INIT_PROCESS|5|init이 생성한 프로세스임을 나타냄|
|LOGIN_PROCESS|6|사용자 로그인을 위한 세션리더 프로세스|
|USER_PROCESS|7|일반 프로세스|
|DEAD_PROCESS|8|종료한 프로세스|
|ACCOUNTING|9|사용하지 않는 항목|

##### (참고) exit_status 구조체  
``` c
struct exit_status{
    short e_termination;
    short e_exit;
};
```
e_termination :  
e_exit : 

##### (참고) timeval 구조체  
``` c
struct timeval{
    time_t          tv_sec;
    suseconds_t     tv_usec;
};
```
tv_sec : 초  
tv_usec : 마이크로초  